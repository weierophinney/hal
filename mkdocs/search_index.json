{
    "docs": [
        {
            "location": "/",
            "text": "Hypertext Application Language (HAL) for PSR-7 Applications\n\n\n\n\n\n\nThis library provides provides utilities for modeling HAL resources with links\nand generating \nPSR-7\n responses representing\nboth JSON and XML serializations of them.\n\n\nInstallation\n\n\nRun the following to install this library:\n\n\n$ composer require weierophinney/hal\n\n\n\n\nDocumentation\n\n\nDocumentation is \nin the doc tree\n, and can be compiled using \nmkdocs\n:\n\n\n$ mkdocs build\n\n\n\n\nYou may also \nbrowse the documentation online\n.",
            "title": "Home"
        },
        {
            "location": "/#hypertext-application-language-hal-for-psr-7-applications",
            "text": "This library provides provides utilities for modeling HAL resources with links\nand generating  PSR-7  responses representing\nboth JSON and XML serializations of them.",
            "title": "Hypertext Application Language (HAL) for PSR-7 Applications"
        },
        {
            "location": "/#installation",
            "text": "Run the following to install this library:  $ composer require weierophinney/hal",
            "title": "Installation"
        },
        {
            "location": "/#documentation",
            "text": "Documentation is  in the doc tree , and can be compiled using  mkdocs :  $ mkdocs build  You may also  browse the documentation online .",
            "title": "Documentation"
        },
        {
            "location": "/intro/",
            "text": "weierophinney/hal\n\n\nThis component provides tools for generating Hypertext Application Language\n(HAL) payloads for your APIs, in both JSON and XML formats.\n\n\nAt its core, it features:\n\n\n\n\nHal\\Link\n, a value object for describing \nrelational links\n.\n\n\nHal\\HalResource\n, a value object for describing your API resource, its\n  relational links, and any embedded/child resources related to it.\n\n\n\n\nThese two tools allow you to model payloads of varying complexity.\n\n\nTo allow providing \nrepresentations\n of these, we provide\n\nHal\\HalResponseFactory\n. This factory generates a \nPSR-7\n\nresponse for the provided resource, including its links and any embedded/child\nresources it composes.\n\n\nCreating link URIs by hand is error-prone, as URI schemas may change; most\nframeworks provide route-based URI generation for this reason. To address\nthis, we provide \nHal\\LinkGenerator\n, and an accompanying interface,\n\nHal\\LinkGenerator\\UrlGenerator\n. You may use these to generate \nLink\n instances\nthat use URIs based on routes you have defined in your application. We also ship\n\nHal\\LinkGenerator\\ExpressiveUrlGenerator\n, which provides a \nUrlGenerator\n\nimplementation backed by the zend-expressive-helpers package.\n\n\nFinally, we recognize that most modern PHP applications use strong data\nmodeling, and thus API payloads need to represent PHP \nobjects\n. To facilitate\nthis, we provide two components:\n\n\n\n\nHal\\Metadata\n is a subcomponent that allows mapping PHP objects to how they\n  should be represented: Should a route be used to generate its self relational\n  link? What zend-hydrator extractor should be used to create a representation\n  of the object? Does the object represent a collection? etc.\n\n\nHal\\ResourceGenerator\n consumes metadata in order to generate \nHalResource\n\n  instances, mapping metadata to specific representation strategies.\n\n\n\n\nThe purpose of the package is to automate creation of HAL payloads, including\nrelational links, from PHP objects.\n\n\nInstallation\n\n\nUse Composer:\n\n\n$ composer require weierophinney/hal\n\n\n\n\nIf you are adding this to an Expressive application, and have the\n\nzend-component-installer\n\npackage installed, this will prompt you to ask if you wish to add it to your\napplication configuration; please do, as the package provides a number of useful\nfactories.\n\n\nWe also recommend installing \nzend-hydrator\n,\nwhich provides facilities for extracting associative array representations of\nPHP objects:\n\n\n$ composer require zendframework/zend-hydrator\n\n\n\n\nFinally, if you want to provide paginated collections, we recommend installing\n\nzend-paginator\n:\n\n\n$ composer require zendframework/zend-paginator\n\n\n\n\nQuick Start\n\n\nThe following examples assume that you have added this package to an Expressive\napplication.\n\n\nEntity and collection classes\n\n\nFor each of our examples, we'll assume the following class exists:\n\n\nnamespace Api\\Books;\n\nclass Book\n{\n    public $id;\n    public $title;\n    public $author;\n}\n\n\n\n\nAdditionally, we'll have a class representing a paginated group of books:\n\n\nnamespace Api\\Books;\n\nuse Zend\\Paginator\\Paginator;\n\nclass BookCollection extends Paginator\n{\n}\n\n\n\n\nRoutes\n\n\nThe examples below assume that we have the following routes defined in our\napplication somehow:\n\n\n\n\n\"book\" will map to a single book by identifier: \"/api/books/{id}\"\n\n\n\"books\" will map to a queryable collection endpoint: \"/api/books\"\n\n\n\n\nCreate metadata\n\n\nIn order to allow creating representations of these classes, we need to provide\nthe resource generator with metadata describing them. This is done via\nconfiguration, which you could put in one of the following places:\n\n\n\n\nA new configuration file: \nconfig/autoload/hal.global.php\n.\n\n\nA \nConfigProvider\n class: \nApi\\Books\\ConfigProvider\n. If you go this route,\n  you will need to add an entry for this class to your \nconfig/config.php\n file.\n\n\n\n\nThe configuration will look like this:\n\n\n// Provide the following imports:\nuse Api\\Books\\Book;\nuse Api\\Books\\BookCollection;\nuse Hal\\Metadata\\MetadataMap;\nuse Hal\\Metadata\\RouteBasedCollectionMetadata;\nuse Hal\\Metadata\\RouteBasedResourceMetadata;\nuse Zend\\Hydrator\\ObjectProperty as ObjectPropertyHydrator;\n\n// And include the following in your configuration:\nMetadataMap::class => [\n    [\n        '__class__' => RouteBasedResourceMetadata::class,\n        'resource_class' => Book::class,\n        'route' => 'book',\n        'extractor' => ObjectPropertyHydrator::class,\n    ],\n    [\n        '__class__' => RouteBasedCollectionMetadata::class,\n        'collection_class' => BookCollection::class,\n        'collection_relation' => 'book',\n        'route' => 'books',\n    ],\n],\n\n\n\n\nManually creating and rendering a resource\n\n\nThe following middleware creates a \nHalResource\n with its associated links, and\nthen manually renders it using \nHal\\Renderer\\JsonRenderer\n. (An \nXmlRenderer\n is\nalso provided, but not demonstrated here.)\n\n\nWe'll assume that \nApi\\Books\\Repository\n handles retrieving data from persistent\nstorage.\n\n\nnamespace Api\\Books\\Action;\n\nuse Api\\Books\\Repository;\nuse Hal\\HalResource;\nuse Hal\\Link;\nuse Hal\\Renderer\\JsonRenderer;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse Zend\\Diactoros\\Response\\TextResponse;\nclass BookAction implements MiddlewareInterface\n{\n    /** @var JsonRenderer */\n    private $renderer;\n    /** @var Repository */\n    private $repository;\n    public function __construct(\n        Repository $repository,\n        JsonRenderer $renderer\n    ) {\n        $this->repository = $repository;\n        $this->renderer = $renderer;\n    }\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $id = $request->getAttribute('id', false);\n        if (! $id) {\n            throw new RuntimeException('No book identifier provided', 400);\n        }\n        $book = $this->repository->get($id);\n        $resource = new HalResource((array) $book);\n        $resource = $resource->withLink(new Link('self'));\n        return new TextResponse(\n            $this->renderer->render($resource),\n            200,\n            ['Content-Type' => 'application/hal+json']\n        );\n    }\n}\n\n\n\n\nThe \nJsonRenderer\n returns the JSON string representing the data and links in\nthe resource. The payload generated might look like the following:\n\n\n{\n    \"_links\": {\n        \"self\": { \"href\": \"/api/books/1234\" }\n    },\n    \"id\": 1234,\n    \"title\": \"Hitchhiker's Guide to the Galaxy\",\n    \"author\": \"Adams, Douglas\"\n}\n\n\n\n\nThe above example uses no metadata, and manually creates the \nHalResource\n\ninstance. As the complexity of your objects increase, and the number of objects\nyou want to represent via HAL increases, you may not want to manually generate\nthem.\n\n\nMiddleware using the ResourceGenerator and ResponseFactory\n\n\nIn this next example, our middleware will compose a \nHal\\ResourceGenerator\n\ninstance for generating a \nHal\\HalResource\n from our objects, and a\n\nHal\\HalResponseFactory\n for creating a response based on the returned resource.\n\n\nFirst, we'll look at middleware that displays a single book. We'll assume that\n\nApi\\Books\\Repository\n handles retrieving data from persistent storage.\n\n\nnamespace Api\\Books\\Action;\n\nuse Api\\Books\\Repository;\nuse Hal\\HalResponseFactory;\nuse Hal\\ResourceGenerator;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\ServerRequestInterface;\nuse RuntimeException;\n\nclass BookAction\n{\n    /** @var Repository */\n    private $repository;\n\n    /** @var ResourceGenerator */\n    private $resourceGenerator;\n\n    /** @var HalResponseFactory */\n    private $responseFactory;\n\n    public function __construct(\n        Repository $repository,\n        ResourceGenerator $resourceGenerator,\n        HalResponseFactory $responseFactory\n    ) {\n        $this->repository = $repository;\n        $this->resourceGenerator = $resourceGenerator;\n        $this->responseFactory = $responseFactory;\n    }\n\n    public function __invoke(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $id = $request->getAttribute('id', false);\n        if (! $id) {\n            throw new RuntimeException('No book identifier provided', 400);\n        }\n\n        /** @var \\Api\\Books\\Book $book */\n        $book = $this->repository->get($id);\n\n        $resource = $this->resourceGenerator->fromObject($book, $request);\n        return $this->responseFactory->createResponse($request, $resource);\n    }\n}\n\n\n\n\nNote that the \n$request\n instance is passed to both the resource generator and\nresponse factory:\n\n\n\n\nThe request is used by the resource generator during link URI generation.\n\n\nThe request is used by the response factory to determine if a JSON or XML\n  payload should be generated.\n\n\n\n\nThe generated payload might look like the following:\n\n\n{\n    \"_links\": {\n        \"self\": { \"href\": \"/api/books/1234\" }\n    },\n    \"id\": 1234,\n    \"title\": \"Hitchhiker's Guide to the Galaxy\",\n    \"author\": \"Adams, Douglas\"\n}\n\n\n\n\nMiddleware returning a collection\n\n\nNext, we'll create middleware that returns a \ncollection\n of books. The\ncollection will be \npaginated\n (assume our repository class creates a\n\nBookCollection\n backed by an appropriate adapter), and use a query string\nparameter to determine which page of results to return.\n\n\nnamespace Api\\Books\\Action;\n\nuse Api\\Books\\Repository;\nuse Hal\\HalResponseFactory;\nuse Hal\\ResourceGenerator;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\ServerRequestInterface;\nuse RuntimeException;\n\nclass BooksAction\n{\n    /** @var Repository */\n    private $repository;\n\n    /** @var ResourceGenerator */\n    private $resourceGenerator;\n\n    /** @var HalResponseFactory */\n    private $responseFactory;\n\n    public function __construct(\n        Repository $repository,\n        ResourceGenerator $resourceGenerator,\n        HalResponseFactory $responseFactory\n    ) {\n        $this->repository = $repository;\n        $this->resourceGenerator = $resourceGenerator;\n        $this->responseFactory = $responseFactory;\n    }\n\n    public function __invoke(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $page = $request->getQueryParams()['page'] ?? 1;\n\n        /** @var \\Api\\Books\\BookCollection $books */\n        $books = $this->repository->fetchAll();\n\n        $books->setItemCountPerPage(25);\n        $books->setCurrentPageNumber($page);\n\n        $resource = $this->resourceGenerator->fromObject($books, $request);\n        return $this->responseFactory->createResponse($request, $resource);\n    }\n}\n\n\n\n\nNote that resource and response generation \nis exactly the same\n as our previous\nexample! This is because the metadata map takes care of the details of\nextracting the data from our value objects and generating links for us.\n\n\nIn this particular example, since we are using a paginator for our collection\nclass, we might get back something like the following:\n\n\n{\n    \"_links\": {\n        \"self\": { \"href\": \"/api/books?page=7\" },\n        \"first\": { \"href\": \"/api/books?page=1\" },\n        \"prev\": { \"href\": \"/api/books?page=6\" },\n        \"next\": { \"href\": \"/api/books?page=8\" },\n        \"last\": { \"href\": \"/api/books?page=17\" }\n        \"search\": {\n            \"href\": \"/api/books?query={searchTerms}\",\n            \"templated\": true\n        }\n    },\n    \"_embedded\": {\n        \"book\": [\n            {\n                \"_links\": {\n                    \"self\": { \"href\": \"/api/books/1234\" }\n                }\n                \"id\": 1234,\n                \"title\": \"Hitchhiker's Guide to the Galaxy\",\n                \"author\": \"Adams, Douglas\"\n            },\n            {\n                \"_links\": {\n                    \"self\": { \"href\": \"/api/books/6789\" }\n                }\n                \"id\": 6789,\n                \"title\": \"Ancillary Justice\",\n                \"author\": \"Leckie, Ann\"\n            },\n            /* ... */\n        ]\n    },\n    \"_page\": 7,\n    \"_per_page\": 25,\n    \"_total\": 407\n}\n\n\n\n\nNext steps\n\n\nThe above examples demonstrate setting up your application to generate and\nreturn HAL resources. In the following chapters, we'll cover:\n\n\n\n\nwhat HAL is, in depth.\n\n\nthe \nHalResource\n and \nLink\n classes, so you can create your own custom\n  resources.\n\n\nthe \nMetadataMap\n and how to both interact with it manually as well as\n  configure it. We'll also cover creating custom metadata types.\n\n\nThe \nResourceGenerator\n, and how you can map metadata types to strategies that\n  generate representations.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#weierophinneyhal",
            "text": "This component provides tools for generating Hypertext Application Language\n(HAL) payloads for your APIs, in both JSON and XML formats.  At its core, it features:   Hal\\Link , a value object for describing  relational links .  Hal\\HalResource , a value object for describing your API resource, its\n  relational links, and any embedded/child resources related to it.   These two tools allow you to model payloads of varying complexity.  To allow providing  representations  of these, we provide Hal\\HalResponseFactory . This factory generates a  PSR-7 \nresponse for the provided resource, including its links and any embedded/child\nresources it composes.  Creating link URIs by hand is error-prone, as URI schemas may change; most\nframeworks provide route-based URI generation for this reason. To address\nthis, we provide  Hal\\LinkGenerator , and an accompanying interface, Hal\\LinkGenerator\\UrlGenerator . You may use these to generate  Link  instances\nthat use URIs based on routes you have defined in your application. We also ship Hal\\LinkGenerator\\ExpressiveUrlGenerator , which provides a  UrlGenerator \nimplementation backed by the zend-expressive-helpers package.  Finally, we recognize that most modern PHP applications use strong data\nmodeling, and thus API payloads need to represent PHP  objects . To facilitate\nthis, we provide two components:   Hal\\Metadata  is a subcomponent that allows mapping PHP objects to how they\n  should be represented: Should a route be used to generate its self relational\n  link? What zend-hydrator extractor should be used to create a representation\n  of the object? Does the object represent a collection? etc.  Hal\\ResourceGenerator  consumes metadata in order to generate  HalResource \n  instances, mapping metadata to specific representation strategies.   The purpose of the package is to automate creation of HAL payloads, including\nrelational links, from PHP objects.",
            "title": "weierophinney/hal"
        },
        {
            "location": "/intro/#installation",
            "text": "Use Composer:  $ composer require weierophinney/hal  If you are adding this to an Expressive application, and have the zend-component-installer \npackage installed, this will prompt you to ask if you wish to add it to your\napplication configuration; please do, as the package provides a number of useful\nfactories.  We also recommend installing  zend-hydrator ,\nwhich provides facilities for extracting associative array representations of\nPHP objects:  $ composer require zendframework/zend-hydrator  Finally, if you want to provide paginated collections, we recommend installing zend-paginator :  $ composer require zendframework/zend-paginator",
            "title": "Installation"
        },
        {
            "location": "/intro/#quick-start",
            "text": "The following examples assume that you have added this package to an Expressive\napplication.",
            "title": "Quick Start"
        },
        {
            "location": "/intro/#entity-and-collection-classes",
            "text": "For each of our examples, we'll assume the following class exists:  namespace Api\\Books;\n\nclass Book\n{\n    public $id;\n    public $title;\n    public $author;\n}  Additionally, we'll have a class representing a paginated group of books:  namespace Api\\Books;\n\nuse Zend\\Paginator\\Paginator;\n\nclass BookCollection extends Paginator\n{\n}",
            "title": "Entity and collection classes"
        },
        {
            "location": "/intro/#routes",
            "text": "The examples below assume that we have the following routes defined in our\napplication somehow:   \"book\" will map to a single book by identifier: \"/api/books/{id}\"  \"books\" will map to a queryable collection endpoint: \"/api/books\"",
            "title": "Routes"
        },
        {
            "location": "/intro/#create-metadata",
            "text": "In order to allow creating representations of these classes, we need to provide\nthe resource generator with metadata describing them. This is done via\nconfiguration, which you could put in one of the following places:   A new configuration file:  config/autoload/hal.global.php .  A  ConfigProvider  class:  Api\\Books\\ConfigProvider . If you go this route,\n  you will need to add an entry for this class to your  config/config.php  file.   The configuration will look like this:  // Provide the following imports:\nuse Api\\Books\\Book;\nuse Api\\Books\\BookCollection;\nuse Hal\\Metadata\\MetadataMap;\nuse Hal\\Metadata\\RouteBasedCollectionMetadata;\nuse Hal\\Metadata\\RouteBasedResourceMetadata;\nuse Zend\\Hydrator\\ObjectProperty as ObjectPropertyHydrator;\n\n// And include the following in your configuration:\nMetadataMap::class => [\n    [\n        '__class__' => RouteBasedResourceMetadata::class,\n        'resource_class' => Book::class,\n        'route' => 'book',\n        'extractor' => ObjectPropertyHydrator::class,\n    ],\n    [\n        '__class__' => RouteBasedCollectionMetadata::class,\n        'collection_class' => BookCollection::class,\n        'collection_relation' => 'book',\n        'route' => 'books',\n    ],\n],",
            "title": "Create metadata"
        },
        {
            "location": "/intro/#manually-creating-and-rendering-a-resource",
            "text": "The following middleware creates a  HalResource  with its associated links, and\nthen manually renders it using  Hal\\Renderer\\JsonRenderer . (An  XmlRenderer  is\nalso provided, but not demonstrated here.)  We'll assume that  Api\\Books\\Repository  handles retrieving data from persistent\nstorage.  namespace Api\\Books\\Action;\n\nuse Api\\Books\\Repository;\nuse Hal\\HalResource;\nuse Hal\\Link;\nuse Hal\\Renderer\\JsonRenderer;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse Zend\\Diactoros\\Response\\TextResponse;\nclass BookAction implements MiddlewareInterface\n{\n    /** @var JsonRenderer */\n    private $renderer;\n    /** @var Repository */\n    private $repository;\n    public function __construct(\n        Repository $repository,\n        JsonRenderer $renderer\n    ) {\n        $this->repository = $repository;\n        $this->renderer = $renderer;\n    }\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $id = $request->getAttribute('id', false);\n        if (! $id) {\n            throw new RuntimeException('No book identifier provided', 400);\n        }\n        $book = $this->repository->get($id);\n        $resource = new HalResource((array) $book);\n        $resource = $resource->withLink(new Link('self'));\n        return new TextResponse(\n            $this->renderer->render($resource),\n            200,\n            ['Content-Type' => 'application/hal+json']\n        );\n    }\n}  The  JsonRenderer  returns the JSON string representing the data and links in\nthe resource. The payload generated might look like the following:  {\n    \"_links\": {\n        \"self\": { \"href\": \"/api/books/1234\" }\n    },\n    \"id\": 1234,\n    \"title\": \"Hitchhiker's Guide to the Galaxy\",\n    \"author\": \"Adams, Douglas\"\n}  The above example uses no metadata, and manually creates the  HalResource \ninstance. As the complexity of your objects increase, and the number of objects\nyou want to represent via HAL increases, you may not want to manually generate\nthem.",
            "title": "Manually creating and rendering a resource"
        },
        {
            "location": "/intro/#middleware-using-the-resourcegenerator-and-responsefactory",
            "text": "In this next example, our middleware will compose a  Hal\\ResourceGenerator \ninstance for generating a  Hal\\HalResource  from our objects, and a Hal\\HalResponseFactory  for creating a response based on the returned resource.  First, we'll look at middleware that displays a single book. We'll assume that Api\\Books\\Repository  handles retrieving data from persistent storage.  namespace Api\\Books\\Action;\n\nuse Api\\Books\\Repository;\nuse Hal\\HalResponseFactory;\nuse Hal\\ResourceGenerator;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\ServerRequestInterface;\nuse RuntimeException;\n\nclass BookAction\n{\n    /** @var Repository */\n    private $repository;\n\n    /** @var ResourceGenerator */\n    private $resourceGenerator;\n\n    /** @var HalResponseFactory */\n    private $responseFactory;\n\n    public function __construct(\n        Repository $repository,\n        ResourceGenerator $resourceGenerator,\n        HalResponseFactory $responseFactory\n    ) {\n        $this->repository = $repository;\n        $this->resourceGenerator = $resourceGenerator;\n        $this->responseFactory = $responseFactory;\n    }\n\n    public function __invoke(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $id = $request->getAttribute('id', false);\n        if (! $id) {\n            throw new RuntimeException('No book identifier provided', 400);\n        }\n\n        /** @var \\Api\\Books\\Book $book */\n        $book = $this->repository->get($id);\n\n        $resource = $this->resourceGenerator->fromObject($book, $request);\n        return $this->responseFactory->createResponse($request, $resource);\n    }\n}  Note that the  $request  instance is passed to both the resource generator and\nresponse factory:   The request is used by the resource generator during link URI generation.  The request is used by the response factory to determine if a JSON or XML\n  payload should be generated.   The generated payload might look like the following:  {\n    \"_links\": {\n        \"self\": { \"href\": \"/api/books/1234\" }\n    },\n    \"id\": 1234,\n    \"title\": \"Hitchhiker's Guide to the Galaxy\",\n    \"author\": \"Adams, Douglas\"\n}",
            "title": "Middleware using the ResourceGenerator and ResponseFactory"
        },
        {
            "location": "/intro/#middleware-returning-a-collection",
            "text": "Next, we'll create middleware that returns a  collection  of books. The\ncollection will be  paginated  (assume our repository class creates a BookCollection  backed by an appropriate adapter), and use a query string\nparameter to determine which page of results to return.  namespace Api\\Books\\Action;\n\nuse Api\\Books\\Repository;\nuse Hal\\HalResponseFactory;\nuse Hal\\ResourceGenerator;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\ServerRequestInterface;\nuse RuntimeException;\n\nclass BooksAction\n{\n    /** @var Repository */\n    private $repository;\n\n    /** @var ResourceGenerator */\n    private $resourceGenerator;\n\n    /** @var HalResponseFactory */\n    private $responseFactory;\n\n    public function __construct(\n        Repository $repository,\n        ResourceGenerator $resourceGenerator,\n        HalResponseFactory $responseFactory\n    ) {\n        $this->repository = $repository;\n        $this->resourceGenerator = $resourceGenerator;\n        $this->responseFactory = $responseFactory;\n    }\n\n    public function __invoke(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $page = $request->getQueryParams()['page'] ?? 1;\n\n        /** @var \\Api\\Books\\BookCollection $books */\n        $books = $this->repository->fetchAll();\n\n        $books->setItemCountPerPage(25);\n        $books->setCurrentPageNumber($page);\n\n        $resource = $this->resourceGenerator->fromObject($books, $request);\n        return $this->responseFactory->createResponse($request, $resource);\n    }\n}  Note that resource and response generation  is exactly the same  as our previous\nexample! This is because the metadata map takes care of the details of\nextracting the data from our value objects and generating links for us.  In this particular example, since we are using a paginator for our collection\nclass, we might get back something like the following:  {\n    \"_links\": {\n        \"self\": { \"href\": \"/api/books?page=7\" },\n        \"first\": { \"href\": \"/api/books?page=1\" },\n        \"prev\": { \"href\": \"/api/books?page=6\" },\n        \"next\": { \"href\": \"/api/books?page=8\" },\n        \"last\": { \"href\": \"/api/books?page=17\" }\n        \"search\": {\n            \"href\": \"/api/books?query={searchTerms}\",\n            \"templated\": true\n        }\n    },\n    \"_embedded\": {\n        \"book\": [\n            {\n                \"_links\": {\n                    \"self\": { \"href\": \"/api/books/1234\" }\n                }\n                \"id\": 1234,\n                \"title\": \"Hitchhiker's Guide to the Galaxy\",\n                \"author\": \"Adams, Douglas\"\n            },\n            {\n                \"_links\": {\n                    \"self\": { \"href\": \"/api/books/6789\" }\n                }\n                \"id\": 6789,\n                \"title\": \"Ancillary Justice\",\n                \"author\": \"Leckie, Ann\"\n            },\n            /* ... */\n        ]\n    },\n    \"_page\": 7,\n    \"_per_page\": 25,\n    \"_total\": 407\n}",
            "title": "Middleware returning a collection"
        },
        {
            "location": "/intro/#next-steps",
            "text": "The above examples demonstrate setting up your application to generate and\nreturn HAL resources. In the following chapters, we'll cover:   what HAL is, in depth.  the  HalResource  and  Link  classes, so you can create your own custom\n  resources.  the  MetadataMap  and how to both interact with it manually as well as\n  configure it. We'll also cover creating custom metadata types.  The  ResourceGenerator , and how you can map metadata types to strategies that\n  generate representations.",
            "title": "Next steps"
        },
        {
            "location": "/hal/",
            "text": "Hypertext Application Language\n\n\nHypertext Application Language\n, or\nHAL) is a \nproposed IETF specification\n\nfor representing API resources and their relations with hyperlinks. While the\noriginal specification targets JSON, an additional IETF proposal\n\ntargets XML\n.\n\n\nHAL is a minimal specification, and addresses three specific things:\n\n\n\n\nHow to represent the elements of an API resource.\n\n\nHow to represent hypertext links of an API resource.\n\n\nHow to represent child resources.\n\n\n\n\nResources\n\n\nHAL opts to keep out of the way. Where other specifications may push the data\nfor a resource into a subkey (e.g., \"data\", \"collection.items\", etc.), HAL\nspecifies resources as the primary payload.\n\n\nAs such, a resource is simply a \ndocument\n:\n\n\n{\n  \"id\": \"XXXX-YYYY-ZZZZ-AAAA\",\n  \"title\": \"Life, the Universe, and Everything\",\n  \"author\": \"Adams, Douglas\"\n}\n\n\n\n\nFor XML documents, the element \n<resource>\n is reserved to detail the resource;\nevery other element represents the document:\n\n\n<resource>\n  <id>XXXX-YYYY-ZZZZ-AAAA</id>\n  <title>Life, the Universe, and Everything</title>\n  <author>Adams, Douglas</author>\n</resource>\n\n\n\n\nThis decision makes both consuming and generating HAL payloads trivial.\n\n\nLinks\n\n\nOne goal of REST is to allow any given resource to provide \nhypertext controls\n,\nor \nlinks\n, allowing the consumer to know what they can do next. Most resources\nwill provide a \nself relational link\n, so that the consumer knows how to request\nthe resource again. However, a consumer might want to know what other actions\nare possible. For example, they may want to know:\n\n\n\n\nhow to get a list of related resources\n\n\nhow to access the first, previous, next, or last pages of a collection of\n  resources\n\n\nwhat resources are related: e.g., transactions, products, invoices, users,\n  etc.\n\n\n\n\nHAL addresses \nhow\n to provide such links. This is necessary because JSON has no\nspecific semantics around linking, and XML, while it has \nsome\n semantics, does\nnot cover how to provide \nmultiple\n links for a given element.\n\n\nHAL addresses JSON by reserving a special \n_links\n property, and specifying a\nstructure for how links are represented. Each element of the \n_links\n property\nis named for the link relation, and the value is either an array, or a link\nobject. A link object contains minimally an \nhref\n property, with several other\nproperties allowed. As an example:\n\n\n{\n  \"_links\": {\n    \"self\": { \"href\": \"/api/books/XXXX-YYYY-ZZZZ-AAAA\" },\n    \"books\": { \"href\": \"/api/books\" }\n  }\n}\n\n\n\n\nAt this point, the consumer knows they can access the current resource via the\n\"self\" relation, and a collection of \"books\" via the URI \"/api/books\".\n\n\nHAL addresses links in XML with two semantics. First, the \n<resource>\n element\ncan contain linking information, using the \"rel\" and \"href\" attributes (and any\nothers necessary to describe the link).  Typically, the \"self\" relational link\nis defined in the \n<resource>\n element. Second, the specification also reserves\nthe \n<link>\n element; the relation, URI, and other attributes become attributes\nof that XML element.\n\n\nAn equivalent XML document to the JSON document above looks like the following:\n\n\n<resource rel=\"self\" href=\"/api/books/XXXX-YYYY-ZZZZ-AAAA\">\n  <link rel=\"books\" href=\"/api/books\"/>\n</resource>\n\n\n\n\nChild Resources\n\n\nAn API payload may have \nchild resources\n for several reasons:\n\n\n\n\nThe resource may be related to the current payload, and providing it directly\n  would prevent another request to the API.\n\n\nThe payload may represent a \ncollection\n of resources (or even \nmultiple\n\n  collections of resources).\n\n\n\n\nGenerally, a child resource represents a \nrelation\n. As such, HAL has very\nspecific semantics for providing them.\n\n\nIn JSON documents, the specification reserves the property \n_embedded\n. This is\nan object, with the keys being the \nrelations\n, and the values either resources,\nor arrays of resources. Each resource follows the same structure as a basic\nHAL resource, with a \n_links\n member, other members representing the resource,\nand optionally an \n_embedded\n member.\n\n\n{\n    \"_links\": {\n        \"self\": { \"href\": \"/api/books?page=7\" },\n        \"first\": { \"href\": \"/api/books?page=1\" },\n        \"prev\": { \"href\": \"/api/books?page=6\" },\n        \"next\": { \"href\": \"/api/books?page=8\" },\n        \"last\": { \"href\": \"/api/books?page=17\" }\n        \"search\": {\n            \"href\": \"/api/books?query={searchTerms}\",\n            \"templated\": true\n        }\n    },\n    \"_embedded\": {\n        \"book\": [\n            {\n                \"_links\": {\n                    \"self\": { \"href\": \"/api/books/1234\" }\n                }\n                \"id\": 1234,\n                \"title\": \"Hitchhiker's Guide to the Galaxy\",\n                \"author\": \"Adams, Douglas\"\n            },\n            {\n                \"_links\": {\n                    \"self\": { \"href\": \"/api/books/6789\" }\n                }\n                \"id\": 6789,\n                \"title\": \"Ancillary Justice\",\n                \"author\": \"Leckie, Ann\"\n            }\n        ]\n    },\n    \"_page\": 7,\n    \"_per_page\": 2,\n    \"_total\": 33\n}\n\n\n\n\nThe above represents a \ncollection\n of \nbook\n resources.\n\n\nTo address XML, the specification uses the \n<resource>\n element to embed\nadditional resources. Resources of the same type use the same \nrel\n attribute.\nThe XML equivalent of the above JSON documentation thus becomes:\n\n\n<resource rel=\"self\" href=\"/api/books?page=7\">\n    <link rel=\"first\" href=\"/api/books?page=1\"/>\n    <link rel=\"prev\" href=\"/api/books?page=6\"/>\n    <link rel=\"next\" href=\"/api/books?page=8\"/>\n    <link rel=\"last\" href=\"/api/books?page=17\" templated=\"true\"/>\n    <resource rel=\"book\" href=\"/api/books/1234\">\n        <id>1234</id>\n        <title>Hitchhiker's Guide to the Galaxy</title>\n        <author>Adams, Douglas</author>\n    </resource>\n    <resource rel=\"book\" href=\"/api/books/6789\">\n        <id>6789</id>\n        <title>Ancillary Justice</title>\n        <author>Leckie, Ann</author>\n    </resource>\n    <_page>7</_page>\n    <_per_page>2</_per_page>\n    <_total>33</_total>\n</resource>\n\n\n\n\nSummary\n\n\nWith these three semantics \u2014 resources, links, and child resources \u2014\nHAL allows you to describe any payload, and provide the hypertext controls\nnecessary to allow API consumers to know what resources they can access next.\n\n\nThe next step, then, is learning how to create HAL payloads for your API!",
            "title": "HAL"
        },
        {
            "location": "/hal/#hypertext-application-language",
            "text": "Hypertext Application Language , or\nHAL) is a  proposed IETF specification \nfor representing API resources and their relations with hyperlinks. While the\noriginal specification targets JSON, an additional IETF proposal targets XML .  HAL is a minimal specification, and addresses three specific things:   How to represent the elements of an API resource.  How to represent hypertext links of an API resource.  How to represent child resources.",
            "title": "Hypertext Application Language"
        },
        {
            "location": "/hal/#resources",
            "text": "HAL opts to keep out of the way. Where other specifications may push the data\nfor a resource into a subkey (e.g., \"data\", \"collection.items\", etc.), HAL\nspecifies resources as the primary payload.  As such, a resource is simply a  document :  {\n  \"id\": \"XXXX-YYYY-ZZZZ-AAAA\",\n  \"title\": \"Life, the Universe, and Everything\",\n  \"author\": \"Adams, Douglas\"\n}  For XML documents, the element  <resource>  is reserved to detail the resource;\nevery other element represents the document:  <resource>\n  <id>XXXX-YYYY-ZZZZ-AAAA</id>\n  <title>Life, the Universe, and Everything</title>\n  <author>Adams, Douglas</author>\n</resource>  This decision makes both consuming and generating HAL payloads trivial.",
            "title": "Resources"
        },
        {
            "location": "/hal/#links",
            "text": "One goal of REST is to allow any given resource to provide  hypertext controls ,\nor  links , allowing the consumer to know what they can do next. Most resources\nwill provide a  self relational link , so that the consumer knows how to request\nthe resource again. However, a consumer might want to know what other actions\nare possible. For example, they may want to know:   how to get a list of related resources  how to access the first, previous, next, or last pages of a collection of\n  resources  what resources are related: e.g., transactions, products, invoices, users,\n  etc.   HAL addresses  how  to provide such links. This is necessary because JSON has no\nspecific semantics around linking, and XML, while it has  some  semantics, does\nnot cover how to provide  multiple  links for a given element.  HAL addresses JSON by reserving a special  _links  property, and specifying a\nstructure for how links are represented. Each element of the  _links  property\nis named for the link relation, and the value is either an array, or a link\nobject. A link object contains minimally an  href  property, with several other\nproperties allowed. As an example:  {\n  \"_links\": {\n    \"self\": { \"href\": \"/api/books/XXXX-YYYY-ZZZZ-AAAA\" },\n    \"books\": { \"href\": \"/api/books\" }\n  }\n}  At this point, the consumer knows they can access the current resource via the\n\"self\" relation, and a collection of \"books\" via the URI \"/api/books\".  HAL addresses links in XML with two semantics. First, the  <resource>  element\ncan contain linking information, using the \"rel\" and \"href\" attributes (and any\nothers necessary to describe the link).  Typically, the \"self\" relational link\nis defined in the  <resource>  element. Second, the specification also reserves\nthe  <link>  element; the relation, URI, and other attributes become attributes\nof that XML element.  An equivalent XML document to the JSON document above looks like the following:  <resource rel=\"self\" href=\"/api/books/XXXX-YYYY-ZZZZ-AAAA\">\n  <link rel=\"books\" href=\"/api/books\"/>\n</resource>",
            "title": "Links"
        },
        {
            "location": "/hal/#child-resources",
            "text": "An API payload may have  child resources  for several reasons:   The resource may be related to the current payload, and providing it directly\n  would prevent another request to the API.  The payload may represent a  collection  of resources (or even  multiple \n  collections of resources).   Generally, a child resource represents a  relation . As such, HAL has very\nspecific semantics for providing them.  In JSON documents, the specification reserves the property  _embedded . This is\nan object, with the keys being the  relations , and the values either resources,\nor arrays of resources. Each resource follows the same structure as a basic\nHAL resource, with a  _links  member, other members representing the resource,\nand optionally an  _embedded  member.  {\n    \"_links\": {\n        \"self\": { \"href\": \"/api/books?page=7\" },\n        \"first\": { \"href\": \"/api/books?page=1\" },\n        \"prev\": { \"href\": \"/api/books?page=6\" },\n        \"next\": { \"href\": \"/api/books?page=8\" },\n        \"last\": { \"href\": \"/api/books?page=17\" }\n        \"search\": {\n            \"href\": \"/api/books?query={searchTerms}\",\n            \"templated\": true\n        }\n    },\n    \"_embedded\": {\n        \"book\": [\n            {\n                \"_links\": {\n                    \"self\": { \"href\": \"/api/books/1234\" }\n                }\n                \"id\": 1234,\n                \"title\": \"Hitchhiker's Guide to the Galaxy\",\n                \"author\": \"Adams, Douglas\"\n            },\n            {\n                \"_links\": {\n                    \"self\": { \"href\": \"/api/books/6789\" }\n                }\n                \"id\": 6789,\n                \"title\": \"Ancillary Justice\",\n                \"author\": \"Leckie, Ann\"\n            }\n        ]\n    },\n    \"_page\": 7,\n    \"_per_page\": 2,\n    \"_total\": 33\n}  The above represents a  collection  of  book  resources.  To address XML, the specification uses the  <resource>  element to embed\nadditional resources. Resources of the same type use the same  rel  attribute.\nThe XML equivalent of the above JSON documentation thus becomes:  <resource rel=\"self\" href=\"/api/books?page=7\">\n    <link rel=\"first\" href=\"/api/books?page=1\"/>\n    <link rel=\"prev\" href=\"/api/books?page=6\"/>\n    <link rel=\"next\" href=\"/api/books?page=8\"/>\n    <link rel=\"last\" href=\"/api/books?page=17\" templated=\"true\"/>\n    <resource rel=\"book\" href=\"/api/books/1234\">\n        <id>1234</id>\n        <title>Hitchhiker's Guide to the Galaxy</title>\n        <author>Adams, Douglas</author>\n    </resource>\n    <resource rel=\"book\" href=\"/api/books/6789\">\n        <id>6789</id>\n        <title>Ancillary Justice</title>\n        <author>Leckie, Ann</author>\n    </resource>\n    <_page>7</_page>\n    <_per_page>2</_per_page>\n    <_total>33</_total>\n</resource>",
            "title": "Child Resources"
        },
        {
            "location": "/hal/#summary",
            "text": "With these three semantics \u2014 resources, links, and child resources \u2014\nHAL allows you to describe any payload, and provide the hypertext controls\nnecessary to allow API consumers to know what resources they can access next.  The next step, then, is learning how to create HAL payloads for your API!",
            "title": "Summary"
        },
        {
            "location": "/links-and-resources/",
            "text": "Links and Resources\n\n\nThe basic building blocks of this component are links and resources:\n\n\n\n\nHal\\Link\n\n\nHal\\HalResource\n\n\n\n\n\n\nNote on naming\n\n\nWhy \nHalResource\n and not the simpler \nResource\n? The answer: PHP. As of PHP\n7, \nresource\n has been designated a potential future language keyword. In\norder to be forwards compatible, we opted to name our class \nHalResource\n.\n\n\nPSR-13\n\n\nweierophinney/hal implements \nPSR-13\n,\nwhich provides interfaces for relational links and collections of relational\nlinks. \nHal\\Link\n implements \nPsr\\Link\\EvolvableLinkInterface\n, and\n\nHal\\HalResource\n implements \nPsr\\Link\\EvolvableLinkProviderInterface\n.\n\n\n\n\nResources compose links, so we'll cover links first.\n\n\nLinks\n\n\nLinks provide URIs to related resources.\n\n\nAny given link, therefore, needs to compose the \nrelation\n and a \nURI\n.\nAdditionally, links:\n\n\n\n\ncan be \ntemplated\n. Templated links have one or more \n{variable}\n placeholders\n  in them that clients can then fill in in order to generate a fully qualified\n  URI.\n\n\ncan contain a number of other attributes: type, title, name, etc.\n\n\n\n\nTo model these, we provide the \nHal\\Link\n class. It has the following\nconstructor:\n\n\npublic function __construct(\n    $relation,\n    string $uri = '',\n    bool $isTemplated = false,\n    array $attributes = []\n)\n\n\n\n\n$relation\n can be a string value, or an array of string values, representing\nthe relation.\n\n\nTo access these various properties, you can use the following methods:\n\n\n$link->getRels()       // get the list of relations for the link\n$link->getHref()       // retrieve the URI\n$link->isTemplated()   // is the link templated?\n$link->getAttributes() // get any additional link attributes\n\n\n\n\nA \nLink\n is \nimmutable\n; you cannot change it after the fact. If you need a\nmodified version of the link, we provide several methods that will return \nnew\ninstances\n containing the changes:\n\n\n$link = $link->withRel($rel);    // or provide an array of relations\n$link = $link->withoutRel($rel); // or provide an array of relations\n$link = $link->withHref($href);\n$link = $link->withAttribute($attribute, $value);\n$link = $link->withoutAttribute($attribute);\n\n\n\n\nWith these tools, you can describe any relational link.\n\n\nRoute-based link URIs\n\n\nMost frameworks provide routing capabilities, and delegate URI generation to\ntheir routers to ensure that generated links conform to known routing\nspecifications. \nLink\n expects only a string URI, however; how can you prevent\nhard-coding that URI?\n\n\nThis component provides a tool for that: \nHal\\LinkGenerator\n. This class\ncomposes a \nHal\\LinkGenerator\\UrlGenerator\n instance, which defines the\nfollowing:\n\n\nnamespace Hal\\LinkGenerator;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface UrlGenerator\n{\n    /**\n     * Generate a URL for use as the HREF of a link.\n     *\n     * - The request is provided, to allow the implementation to pull any\n     *   request-specific items it may need (e.g., results of routing, original\n     *   URI for purposes of generating a fully-qualified URI, etc.).\n     *\n     * - `$routeParams` are any replacements to make in the route string.\n     *\n     * - `$queryParams` are any query string parameters to include in the\n     *   generated URL.\n     */\n    public function generate(\n        ServerRequestInterface $request,\n        string $routeName,\n        array $routeParams = [],\n        array $queryParams = []\n    ) : string;\n}\n\n\n\n\nWe provide a default implementation for Expressive users,\n\nHal\\LinkGenerator\\ExpressiveUrlGenerator\n,  that uses the \nUrlHelper\n and\n\nServerUrlHelper\n from zend-expressive-helpers in order to generate URIs.\n\n\nThe \nLinkGenerator\n itself defines two methods:\n\n\n$link = $linkGenerator->fromRoute(\n    $relation,\n    $request,\n    $routeName,\n    $routeParams, // Array of additional route parameters to inject\n    $queryParams, // Array of query string arguments to inject\n    $attributes   // Array of Link attributes to use\n);\n\n$link = $linkGenerator->templatedFromRoute(\n    $relation,\n    $request,\n    $routeName,\n    $routeParams, // Array of additional route parameters to inject\n    $queryParams, // Array of query string arguments to inject\n    $attributes   // Array of Link attributes to use\n);\n\n\n\n\nfromRoute()\n will generate a non-templated \nLink\n instance, while\n\ntemplatedFromRoute()\n generates a templated instance.\n\n\nIf you need to generate custom links based on routing, we recommend composing\nthe \nLinkGenerator\n in your own classes to do so.\n\n\nResources\n\n\nA HAL resource is simply the representation you want to return for your API.\n\nHal\\HalResource\n allows you to model these representations, along with any\nrelational links and child resources.\n\n\nIt defines the following constructor:\n\n\npublic function __construct(\n    array $data = [],\n    array $links = [],\n    array $embedded = []\n)\n\n\n\n\n$data\n should be an associative array of data you wish to include in your\nrepresentation; the only limitation is you may not use the keys \n_links\n or\n\n_embedded\n, as these are reserved keywords.\n\n\n$links\n should be an array of \nHal\\Link\n instances.\n\n\n$embedded\n should be an array of \nHal\\HalResource\n instances. Most often,\nhowever, you will include these with \n$data\n, as the class contains logic for\nidentifying them.\n\n\nOnce you have created an instance, you can access its properties:\n\n\n$resource->getElement($name) // retrieve an element or embedded resource by name\n$resource->getElements()     // retrieve all elements and embedded resources\n$resource->getLinks()        // retrieve all relational links\n$resource->getLinksByRel()   // retrieve links for a specific relation\n$resource->toArray()         // retrieve associative array representation\n\n\n\n\nHalResource\n instances are \nimmutable\n. We provide a number of methods that\nallow you to create \nnew instances\n with changes:\n\n\n$resource = $resource->withElement($name, $value);\n$resource = $resource->withoutElement($name);\n$resource = $resource->withElements($elements);\n$resource = $resource->embed($name, $resource);\n$resource = $resource->withLink($link);\n$resource = $resource->withoutLink($link);\n\n\n\n\nWith these tools, you can describe any resource you want to represent.",
            "title": "Links and Resources"
        },
        {
            "location": "/links-and-resources/#links-and-resources",
            "text": "The basic building blocks of this component are links and resources:   Hal\\Link  Hal\\HalResource",
            "title": "Links and Resources"
        },
        {
            "location": "/links-and-resources/#note-on-naming",
            "text": "Why  HalResource  and not the simpler  Resource ? The answer: PHP. As of PHP\n7,  resource  has been designated a potential future language keyword. In\norder to be forwards compatible, we opted to name our class  HalResource .",
            "title": "Note on naming"
        },
        {
            "location": "/links-and-resources/#psr-13",
            "text": "weierophinney/hal implements  PSR-13 ,\nwhich provides interfaces for relational links and collections of relational\nlinks.  Hal\\Link  implements  Psr\\Link\\EvolvableLinkInterface , and Hal\\HalResource  implements  Psr\\Link\\EvolvableLinkProviderInterface .   Resources compose links, so we'll cover links first.",
            "title": "PSR-13"
        },
        {
            "location": "/links-and-resources/#links",
            "text": "Links provide URIs to related resources.  Any given link, therefore, needs to compose the  relation  and a  URI .\nAdditionally, links:   can be  templated . Templated links have one or more  {variable}  placeholders\n  in them that clients can then fill in in order to generate a fully qualified\n  URI.  can contain a number of other attributes: type, title, name, etc.   To model these, we provide the  Hal\\Link  class. It has the following\nconstructor:  public function __construct(\n    $relation,\n    string $uri = '',\n    bool $isTemplated = false,\n    array $attributes = []\n)  $relation  can be a string value, or an array of string values, representing\nthe relation.  To access these various properties, you can use the following methods:  $link->getRels()       // get the list of relations for the link\n$link->getHref()       // retrieve the URI\n$link->isTemplated()   // is the link templated?\n$link->getAttributes() // get any additional link attributes  A  Link  is  immutable ; you cannot change it after the fact. If you need a\nmodified version of the link, we provide several methods that will return  new\ninstances  containing the changes:  $link = $link->withRel($rel);    // or provide an array of relations\n$link = $link->withoutRel($rel); // or provide an array of relations\n$link = $link->withHref($href);\n$link = $link->withAttribute($attribute, $value);\n$link = $link->withoutAttribute($attribute);  With these tools, you can describe any relational link.",
            "title": "Links"
        },
        {
            "location": "/links-and-resources/#route-based-link-uris",
            "text": "Most frameworks provide routing capabilities, and delegate URI generation to\ntheir routers to ensure that generated links conform to known routing\nspecifications.  Link  expects only a string URI, however; how can you prevent\nhard-coding that URI?  This component provides a tool for that:  Hal\\LinkGenerator . This class\ncomposes a  Hal\\LinkGenerator\\UrlGenerator  instance, which defines the\nfollowing:  namespace Hal\\LinkGenerator;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface UrlGenerator\n{\n    /**\n     * Generate a URL for use as the HREF of a link.\n     *\n     * - The request is provided, to allow the implementation to pull any\n     *   request-specific items it may need (e.g., results of routing, original\n     *   URI for purposes of generating a fully-qualified URI, etc.).\n     *\n     * - `$routeParams` are any replacements to make in the route string.\n     *\n     * - `$queryParams` are any query string parameters to include in the\n     *   generated URL.\n     */\n    public function generate(\n        ServerRequestInterface $request,\n        string $routeName,\n        array $routeParams = [],\n        array $queryParams = []\n    ) : string;\n}  We provide a default implementation for Expressive users, Hal\\LinkGenerator\\ExpressiveUrlGenerator ,  that uses the  UrlHelper  and ServerUrlHelper  from zend-expressive-helpers in order to generate URIs.  The  LinkGenerator  itself defines two methods:  $link = $linkGenerator->fromRoute(\n    $relation,\n    $request,\n    $routeName,\n    $routeParams, // Array of additional route parameters to inject\n    $queryParams, // Array of query string arguments to inject\n    $attributes   // Array of Link attributes to use\n);\n\n$link = $linkGenerator->templatedFromRoute(\n    $relation,\n    $request,\n    $routeName,\n    $routeParams, // Array of additional route parameters to inject\n    $queryParams, // Array of query string arguments to inject\n    $attributes   // Array of Link attributes to use\n);  fromRoute()  will generate a non-templated  Link  instance, while templatedFromRoute()  generates a templated instance.  If you need to generate custom links based on routing, we recommend composing\nthe  LinkGenerator  in your own classes to do so.",
            "title": "Route-based link URIs"
        },
        {
            "location": "/links-and-resources/#resources",
            "text": "A HAL resource is simply the representation you want to return for your API. Hal\\HalResource  allows you to model these representations, along with any\nrelational links and child resources.  It defines the following constructor:  public function __construct(\n    array $data = [],\n    array $links = [],\n    array $embedded = []\n)  $data  should be an associative array of data you wish to include in your\nrepresentation; the only limitation is you may not use the keys  _links  or _embedded , as these are reserved keywords.  $links  should be an array of  Hal\\Link  instances.  $embedded  should be an array of  Hal\\HalResource  instances. Most often,\nhowever, you will include these with  $data , as the class contains logic for\nidentifying them.  Once you have created an instance, you can access its properties:  $resource->getElement($name) // retrieve an element or embedded resource by name\n$resource->getElements()     // retrieve all elements and embedded resources\n$resource->getLinks()        // retrieve all relational links\n$resource->getLinksByRel()   // retrieve links for a specific relation\n$resource->toArray()         // retrieve associative array representation  HalResource  instances are  immutable . We provide a number of methods that\nallow you to create  new instances  with changes:  $resource = $resource->withElement($name, $value);\n$resource = $resource->withoutElement($name);\n$resource = $resource->withElements($elements);\n$resource = $resource->embed($name, $resource);\n$resource = $resource->withLink($link);\n$resource = $resource->withoutLink($link);  With these tools, you can describe any resource you want to represent.",
            "title": "Resources"
        },
        {
            "location": "/resource-generator/",
            "text": "Generating Resources from PHP Objects\n\n\nIn the previous chapter, \nwe discussed links and resources\n.\nThe primitive objects allow us to create representations easily, but do not\nanswer one critical question: how can we create resources based on existing PHP\nobject types?\n\n\nTo answer that question, we provide two related features: metadata, and a\nresource generator.\n\n\nMetadata\n\n\nMetadata allows you to detail the requirements for generating a HAL\nrepresentation of a PHP object. Metadata might include:\n\n\n\n\nThe PHP class name to represent.\n\n\nA URI to use for the generated resource's self relational link.\n\n\nAlternately, routing information to use with the \nLinkGenerator\n.\n\n\nA zend-hydrator extractor to use to serialize the object to a representation.\n\n\nWhether or not the resource is a collection, and, if so, whether pagination is\n  handled as a path parameter or a query string argument, the name of the\n  parameter, etc.\n\n\n\n\nAll metadata types inherit from \nHal\\Metadata\\AbstractMetadata\n, which defines a\nsingle method, \ngetClass()\n, for retrieving the name of the PHP class to\nrepresent; all metadata are expected to inherit from this class.\n\n\nThe component also provides four concrete metadata types, requiring the\nfollowing information:\n\n\n\n\nHal\\Metadata\\RouteBasedCollectionMetadata\n:\n\n\nstring \n$class\n\n\nstring \n$collectionRelation\n\n\nstring \n$route\n\n\nstring \n$paginationParam = 'page'\n (name of the parameter indicating the\n  current page of results)\n\n\nstring \n$paginationParamType = self::TYPE_QUERY\n (one of \"query\" or \"placeholder\")\n\n\narray \n$routeParams = []\n (associative array of substitutions to use with\n  the designated route)\n\n\narray \n$queryStringArguments = []\n (associative array of query string\n  arguments to include in the generated URI)\n\n\n\n\n\n\nHal\\Metadata\\RouteBasedResourceMetadata\n:\n\n\nstring \n$class\n\n\nstring \n$route\n\n\nstring \n$extractor\n (string service name of the zend-hydrator hydrator to\n  use for extracting data from the instance)\n\n\nstring \n$resourceIdentifier = 'id'\n (name of the property uniquely\n  identifying the resource)\n\n\nstring \n$routeIdentifierPlaceholder = 'id'\n (name of the routing parameter\n  that maps to the resource identifier)\n\n\narray \n$routeParams = []\n (associative array of additional routing\n  parameters to substitute when generating the URI)\n\n\n\n\n\n\nHal\\Metadata\\UrlBasedCollectionMetadata\n:\n\n\nstring \n$class\n\n\nstring \n$collectionRelation\n\n\nstring \n$url\n\n\nstring \n$paginationParam = 'page'\n (name of the parameter indicating the\n  current page of results)\n\n\nstring \n$paginationParamType = self::TYPE_QUERY\n (one of \"query\" or \"placeholder\")\n\n\n\n\n\n\n\n\nWe aggregate metadata in a \nHal\\Metadata\\MetadataMap\n instance:\n\n\n$bookMetadata = new RouteBasedResourceMetadata(\n    Book::class,\n    'book',\n    ObjectPropertyHydrator::class\n);\n$booksMetadata = new RouteBasedCollectionMetadata(\n    BookCollection::class,\n    'book',\n    'books',\n);\n\n$metadataMap = new MetadataMap();\n$metadataMap->add($bookMetadata);\n$metadataMap->add($booksMetadata);\n\n\n\n\nConfiguration-based metadata\n\n\nTo automate generation of the \nMetadataMap\n, we provide\n\nHal\\Metadata\\MetadataMapFactory\n. This factory may be used with any\n\nPSR-11\n container. It utilizes the \nconfig\n\nservice, and pulls its configuration from a key named after the\n\nHal\\Metadata\\MetadataMap\n class.\n\n\nEach item in the map will be an associative array. The member \n__class__\n will\ndescribe which metadata class to create, and the remaining properties will then\nbe used to generate an instance. As an example, the above could be configured as\nfollows:\n\n\nuse Api\\Books\\Book;\nuse Api\\Books\\BookCollection;\nuse Hal\\Metadata\\MetadataMap;\nuse Hal\\Metadata\\RouteBasedCollectionMetadata;\nuse Hal\\Metadata\\RouteBasedResourceMetadata;\nuse Zend\\Hydrator\\ObjectProperty;\n\nreturn [\n    'Hal\\Metadata\\MetadataMap' => [\n        [\n            '__class__' => RouteBasedResourceMetadata::class,\n            'resource_class' => Book::class,\n            'route' => 'book',\n            'extractor' => ObjectProperty::class,\n        ],\n        [\n            '__class__' => RouteBasedCollectionMetadata::class,\n            'collection_class' => BookCollection::class,\n            'collection_relation' => 'book',\n            'route' => 'books',\n        ],\n    ],\n];\n\n\n\n\nResourceGenerator\n\n\nOnce you have defined the metadata for the various objects you will represent in\nyour API, you can start generating resources.\n\n\nHal\\ResourceGenerator\n has the following constructor:\n\n\npublic function __construct(\n    Hal\\Metadata\\MetadataMap $metadataMap,\n    Psr\\Container\\ContainerInterface $hydrators,\n    Hal\\LinkGenerator $linkGenerator\n) {\n\n\n\n\nWe described the \nMetadataMap\n in the previous section, and the \nLinkGenerator\n\nin the \nprevious chapter\n.\n\n\nHydrators are defind in the \nzend-hydrator component\n,\nand are objects which can \nhdyrate\n associative arrays to object instances and\n\nextract\n associative arrays from object instances. Generally speaking, the\n\n$hydrators\n instance may be any PSR-11 container, but you will generally want\nto use the \nZend\\Hydrator\\HydratorPluginManager\n.\n\n\nOnce you have your instance created, you can start generating resources:\n\n\n$resource = $resourceGenerator->fromObject($book, $request);\n\n\n\n\n(Where \n$request\n is a \nPsr\\Http\\Message\\ServerRequestInterface\n instance; the\ninstance is passed along to the \nLinkGenerator\n in order to generate route-based\nURIs for \nLink\n instances.)\n\n\nCustomizing resource generation\n\n\nThe \nResourceGenerator\n allows composing \nHal\\ResourceGenerator\\Strategy\n\ninstances. The \nStrategy\n interface defines the following:\n\n\nnamespace Hal\\ResourceGenerator;\n\nuse Hal\\HalResource;\nuse Hal\\Metadata;\nuse Hal\\ResourceGenerator;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface Strategy\n{\n    /**\n     * @param object $instance Instance from which to create Resource.\n     * @throws Exception\\UnexpectedMetadataTypeException for metadata types the\n     *     strategy cannot handle.\n     */\n    public function createResource(\n        $instance,\n        Metadata\\AbstractMetadata $metadata,\n        ResourceGenerator $resourceGenerator,\n        ServerRequestInterface $request\n    ) : HalResource;\n}\n\n\n\n\nWhen you register a strategy, you will map a metadata type to the strategy; the\n\nResourceGenerator\n will then call your strategy whenever it encounteres\nmetadata of that type.\n\n\n$resourceGenerator->addStrategy(CustomMetadata::class, CustomStrategy::class);\n\n// or:\n$resourceGenerator->addStrategy(CustomMetadata::class, $strategyInstance);\n\n\n\n\nIf a strategy already is mapped for the given metadata type, this method will\noverride it.\n\n\nTo facilitate common operations, this library provides two traits,\n\nHal\\ResourceGenerator\\ExtractCollection\n and\n\nHal\\ResourceGenerator\\ExtractInstance\n; inspect these if you decide to write\nyour own strategies.",
            "title": "Generating Resources"
        },
        {
            "location": "/resource-generator/#generating-resources-from-php-objects",
            "text": "In the previous chapter,  we discussed links and resources .\nThe primitive objects allow us to create representations easily, but do not\nanswer one critical question: how can we create resources based on existing PHP\nobject types?  To answer that question, we provide two related features: metadata, and a\nresource generator.",
            "title": "Generating Resources from PHP Objects"
        },
        {
            "location": "/resource-generator/#metadata",
            "text": "Metadata allows you to detail the requirements for generating a HAL\nrepresentation of a PHP object. Metadata might include:   The PHP class name to represent.  A URI to use for the generated resource's self relational link.  Alternately, routing information to use with the  LinkGenerator .  A zend-hydrator extractor to use to serialize the object to a representation.  Whether or not the resource is a collection, and, if so, whether pagination is\n  handled as a path parameter or a query string argument, the name of the\n  parameter, etc.   All metadata types inherit from  Hal\\Metadata\\AbstractMetadata , which defines a\nsingle method,  getClass() , for retrieving the name of the PHP class to\nrepresent; all metadata are expected to inherit from this class.  The component also provides four concrete metadata types, requiring the\nfollowing information:   Hal\\Metadata\\RouteBasedCollectionMetadata :  string  $class  string  $collectionRelation  string  $route  string  $paginationParam = 'page'  (name of the parameter indicating the\n  current page of results)  string  $paginationParamType = self::TYPE_QUERY  (one of \"query\" or \"placeholder\")  array  $routeParams = []  (associative array of substitutions to use with\n  the designated route)  array  $queryStringArguments = []  (associative array of query string\n  arguments to include in the generated URI)    Hal\\Metadata\\RouteBasedResourceMetadata :  string  $class  string  $route  string  $extractor  (string service name of the zend-hydrator hydrator to\n  use for extracting data from the instance)  string  $resourceIdentifier = 'id'  (name of the property uniquely\n  identifying the resource)  string  $routeIdentifierPlaceholder = 'id'  (name of the routing parameter\n  that maps to the resource identifier)  array  $routeParams = []  (associative array of additional routing\n  parameters to substitute when generating the URI)    Hal\\Metadata\\UrlBasedCollectionMetadata :  string  $class  string  $collectionRelation  string  $url  string  $paginationParam = 'page'  (name of the parameter indicating the\n  current page of results)  string  $paginationParamType = self::TYPE_QUERY  (one of \"query\" or \"placeholder\")     We aggregate metadata in a  Hal\\Metadata\\MetadataMap  instance:  $bookMetadata = new RouteBasedResourceMetadata(\n    Book::class,\n    'book',\n    ObjectPropertyHydrator::class\n);\n$booksMetadata = new RouteBasedCollectionMetadata(\n    BookCollection::class,\n    'book',\n    'books',\n);\n\n$metadataMap = new MetadataMap();\n$metadataMap->add($bookMetadata);\n$metadataMap->add($booksMetadata);",
            "title": "Metadata"
        },
        {
            "location": "/resource-generator/#configuration-based-metadata",
            "text": "To automate generation of the  MetadataMap , we provide Hal\\Metadata\\MetadataMapFactory . This factory may be used with any PSR-11  container. It utilizes the  config \nservice, and pulls its configuration from a key named after the Hal\\Metadata\\MetadataMap  class.  Each item in the map will be an associative array. The member  __class__  will\ndescribe which metadata class to create, and the remaining properties will then\nbe used to generate an instance. As an example, the above could be configured as\nfollows:  use Api\\Books\\Book;\nuse Api\\Books\\BookCollection;\nuse Hal\\Metadata\\MetadataMap;\nuse Hal\\Metadata\\RouteBasedCollectionMetadata;\nuse Hal\\Metadata\\RouteBasedResourceMetadata;\nuse Zend\\Hydrator\\ObjectProperty;\n\nreturn [\n    'Hal\\Metadata\\MetadataMap' => [\n        [\n            '__class__' => RouteBasedResourceMetadata::class,\n            'resource_class' => Book::class,\n            'route' => 'book',\n            'extractor' => ObjectProperty::class,\n        ],\n        [\n            '__class__' => RouteBasedCollectionMetadata::class,\n            'collection_class' => BookCollection::class,\n            'collection_relation' => 'book',\n            'route' => 'books',\n        ],\n    ],\n];",
            "title": "Configuration-based metadata"
        },
        {
            "location": "/resource-generator/#resourcegenerator",
            "text": "Once you have defined the metadata for the various objects you will represent in\nyour API, you can start generating resources.  Hal\\ResourceGenerator  has the following constructor:  public function __construct(\n    Hal\\Metadata\\MetadataMap $metadataMap,\n    Psr\\Container\\ContainerInterface $hydrators,\n    Hal\\LinkGenerator $linkGenerator\n) {  We described the  MetadataMap  in the previous section, and the  LinkGenerator \nin the  previous chapter .  Hydrators are defind in the  zend-hydrator component ,\nand are objects which can  hdyrate  associative arrays to object instances and extract  associative arrays from object instances. Generally speaking, the $hydrators  instance may be any PSR-11 container, but you will generally want\nto use the  Zend\\Hydrator\\HydratorPluginManager .  Once you have your instance created, you can start generating resources:  $resource = $resourceGenerator->fromObject($book, $request);  (Where  $request  is a  Psr\\Http\\Message\\ServerRequestInterface  instance; the\ninstance is passed along to the  LinkGenerator  in order to generate route-based\nURIs for  Link  instances.)",
            "title": "ResourceGenerator"
        },
        {
            "location": "/resource-generator/#customizing-resource-generation",
            "text": "The  ResourceGenerator  allows composing  Hal\\ResourceGenerator\\Strategy \ninstances. The  Strategy  interface defines the following:  namespace Hal\\ResourceGenerator;\n\nuse Hal\\HalResource;\nuse Hal\\Metadata;\nuse Hal\\ResourceGenerator;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface Strategy\n{\n    /**\n     * @param object $instance Instance from which to create Resource.\n     * @throws Exception\\UnexpectedMetadataTypeException for metadata types the\n     *     strategy cannot handle.\n     */\n    public function createResource(\n        $instance,\n        Metadata\\AbstractMetadata $metadata,\n        ResourceGenerator $resourceGenerator,\n        ServerRequestInterface $request\n    ) : HalResource;\n}  When you register a strategy, you will map a metadata type to the strategy; the ResourceGenerator  will then call your strategy whenever it encounteres\nmetadata of that type.  $resourceGenerator->addStrategy(CustomMetadata::class, CustomStrategy::class);\n\n// or:\n$resourceGenerator->addStrategy(CustomMetadata::class, $strategyInstance);  If a strategy already is mapped for the given metadata type, this method will\noverride it.  To facilitate common operations, this library provides two traits, Hal\\ResourceGenerator\\ExtractCollection  and Hal\\ResourceGenerator\\ExtractInstance ; inspect these if you decide to write\nyour own strategies.",
            "title": "Customizing resource generation"
        },
        {
            "location": "/representations/",
            "text": "Generating Representations\n\n\nThis component provides two renderers, one each for creating JSON and XML\npayloads.\n\n\nAdditionally, as noted in the \nintroduction\n examples, this component\nprovides \nHal\\HalResponseFactory\n for generating a PSR-7 response containing the\nHAL representation. This chapter dives into that with more detail.\n\n\nRenderers\n\n\nAll renderers implement \nHal\\Renderer\\Renderer\n:\n\n\nnamespace Hal\\Renderer;\n\nuse Hal\\HalResource;\n\ninterface Renderer\n{\n    public function render(HalResource $resource) : string;\n}\n\n\n\n\nTwo implementations are provided, \nHal\\Renderer\\JsonRenderer\n and\n\nHal\\Renderer\\XmlRenderer\n\n\nJsonRenderer\n\n\nThe \nJsonRenderer\n constructor allows you to specify a bitmask of flags for use\nwith \njson_encode()\n. By default, if none are provided, it uses the value of\n\nJsonRenderer::DEFAULT_JSON_FLAGS\n, which evaluates to:\n\n\nJSON_PRETTY_PRINT\n| JSON_UNESCAPED_SLASHES\n| JSON_UNESCAPED_UNICODE\n| JSON_PRESERVE_ZERO_FRACTION\n\n\n\n\nThis provides human-readable JSON output.\n\n\nXmlRenderer\n\n\nThe \nXmlRenderer\n produces XML representations of HAL resources. It has no\nconstructor arguments at this time.\n\n\nHalResponseFactory\n\n\nHalResponseFactory\n generates a PSR-7 response containing a representation of\nthe provided \nHalResource\n instance. In order to keep the component agnostic of\nPSR-7 implementation, the factory composes:\n\n\n\n\nA PSR-7 response prototype. A zend-diactoros \nResponse\n is used if none is\n  provided.\n\n\nA callable capable of generating an empty, writable, PSR-7 stream instance.\n  If none is provided, a callable returning a zend-diactoros \nStream\n is\n  provided.\n\n\n\n\nAs an example:\n\n\nuse Hal\\HalResponseFactory;\nuse Slim\\Http\\Response;\nuse Slim\\Http\\Stream;\n\n$factory = new HalResponseFactory(\n    new Response(),\n    function () {\n        return new Stream(fopen('php://temp', 'wb+'));\n    }\n);\n\n\n\n\n\n\nStreams\n\n\nA factory callable is necessary for generating streams as they are usually\nbacked by PHP resources, which are not immutable. Sharing instances could\nthus potentially lead to appending or overwriting contents!\n\n\n\n\nBy default, if you pass no arguments to the \nHalResponseFactory\n constructor, it\nassumes the following:\n\n\n\n\nUsage of \nZend\\Diactoros\\Response\n.\n\n\nA callable that returns a new \nZend\\Diactoros\\Stream\n using \nphp://temp\n as\n  its backing resource.\n\n\nA \nJsonRenderer\n instance is created if none is provided.\n\n\nAn \nXmlRenderer\n instance is created if none is provided.\n\n\n\n\nWe provide a PSR-11 compatible factory for generating the \nHalResponseFactory\n\nwhich uses zend-diactoros by default.\n\n\nUsing the factory\n\n\nThe factory exposes one method:\n\n\nuse Hal\\HalResource;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\npublic function createResponse(\n    ServerRequestInterface $request,\n    HalResource $resource,\n    string $mediaType = self::DEFAULT_CONTENT_TYPE\n) : ResponseInterface {\n\n\n\n\nGenerally speaking, you'll pass the current request instance, and the resource\nfor which you want to generate a response, and the factory will return a\nresponse based on its response prototype, with the following:\n\n\n\n\nA \nContent-Type\n header with the base media type of \napplication/hal\n.\n\n\nA message body containing the representation.\n\n\n\n\nThe request instance is used to determine what representation to create, based\non the \nAccept\n header. If it matches a JSON media type, a JSON representation\nis created, and the \nContent-Type\n will be appended with \n+json\n; for XML, an\nXML representation is created, and the \nContent-Type\n will be appended with\n\n+xml\n. If no media type is matched, XML is generated.\n\n\nOne practice often used is to provide a \ncustom media type\n for your\nrepresentations. While they will still be HAL, this allows you to document the\nspecific structure of your resources, and potentially even validate them against\nJSON schema.\n\n\nTo do this, pass the media type when creating the response:\n\n\n$response = $factory->createResponse(\n    $request,\n    $resource,\n    'application/vnd.book'\n);\n\n\n\n\nDo not\n pass the format (e.g., \n+json\n, \n+xml\n) when doing so; the factory will\nappend the appropriate one based on content negotiation.\n\n\nForcing collections for relations\n\n\nHAL allows links and embedded resources to be represented as:\n\n\n\n\na single object\n\n\nan array of objects of the same type\n\n\n\n\nInternally, this package checks to see if only one of the item exists, and, if\nso, it will render it by itself. However, there are times you may want to force\nan array representation. As an example, if your resource models a car, and you\nhave a \nwheels\n relation, it would not make sense to return a single wheel, even\nif that's all the car currently has associated with it.\n\n\nTo accommodate this, we provide two features.\n\n\nFor links, you may pass a special attribute, \nHal\\Link::AS_COLLECTION\n, with a\nboolean value of \ntrue\n; when encountered, this will then be rendered as an\narray of links, even if only one link for that relation is present.\n\n\n$link = new Link(\n    'wheels',\n    '/api/car/XXXX-YYYY-ZZZZ/wheels/111',\n    false,\n    [Link::AS_COLLECTION => true]\n);\n\n$resource = $resource->withLink($link);\n\n\n\n\nIn the above, you will then get the following within your representation:\n\n\n\"_links\": {\n  \"wheels\": [\n    {\"href\": \"/api/car/XXXX-YYYY-ZZZZ/wheels/111\"}\n  ]\n}\n\n\n\n\nTo force an embedded resource to be rendered within an array, you have two\noptions.\n\n\nFirst, and simplest, pass the resource within an array when calling\n\nwithElement()\n, \nembed()\n, or passing data to the constructor:\n\n\n// Constructor:\n$resource = new HalResource(['wheels' => [$wheel]]);\n\n// withElement():\n$resource = $resource->withElement('wheels', [$wheel]);\n\n// embed():\n$resource = $resource->embed('wheels', [$wheel]);\n\n\n\n\nAlternately, you can call the \nHalResource::embed\n method with only the\nresource, passing the method a third argument, a flag indicating whether or not\nto force an array:\n\n\n$resource = $resource->embed('wheels', $wheel, true);\n\n\n\n\nIn each of these cases, assuming no other wheels were provided to the final\nresource, you might get a representation such as the following:\n\n\n\"_embedded\": {\n  \"wheels\": [\n    {\n      \"_links\" => {\"self\": {\"href\": \"...\"}}\n      \"id\": \"...\"\n    },\n  ]\n}",
            "title": "Representations"
        },
        {
            "location": "/representations/#generating-representations",
            "text": "This component provides two renderers, one each for creating JSON and XML\npayloads.  Additionally, as noted in the  introduction  examples, this component\nprovides  Hal\\HalResponseFactory  for generating a PSR-7 response containing the\nHAL representation. This chapter dives into that with more detail.",
            "title": "Generating Representations"
        },
        {
            "location": "/representations/#renderers",
            "text": "All renderers implement  Hal\\Renderer\\Renderer :  namespace Hal\\Renderer;\n\nuse Hal\\HalResource;\n\ninterface Renderer\n{\n    public function render(HalResource $resource) : string;\n}  Two implementations are provided,  Hal\\Renderer\\JsonRenderer  and Hal\\Renderer\\XmlRenderer",
            "title": "Renderers"
        },
        {
            "location": "/representations/#jsonrenderer",
            "text": "The  JsonRenderer  constructor allows you to specify a bitmask of flags for use\nwith  json_encode() . By default, if none are provided, it uses the value of JsonRenderer::DEFAULT_JSON_FLAGS , which evaluates to:  JSON_PRETTY_PRINT\n| JSON_UNESCAPED_SLASHES\n| JSON_UNESCAPED_UNICODE\n| JSON_PRESERVE_ZERO_FRACTION  This provides human-readable JSON output.",
            "title": "JsonRenderer"
        },
        {
            "location": "/representations/#xmlrenderer",
            "text": "The  XmlRenderer  produces XML representations of HAL resources. It has no\nconstructor arguments at this time.",
            "title": "XmlRenderer"
        },
        {
            "location": "/representations/#halresponsefactory",
            "text": "HalResponseFactory  generates a PSR-7 response containing a representation of\nthe provided  HalResource  instance. In order to keep the component agnostic of\nPSR-7 implementation, the factory composes:   A PSR-7 response prototype. A zend-diactoros  Response  is used if none is\n  provided.  A callable capable of generating an empty, writable, PSR-7 stream instance.\n  If none is provided, a callable returning a zend-diactoros  Stream  is\n  provided.   As an example:  use Hal\\HalResponseFactory;\nuse Slim\\Http\\Response;\nuse Slim\\Http\\Stream;\n\n$factory = new HalResponseFactory(\n    new Response(),\n    function () {\n        return new Stream(fopen('php://temp', 'wb+'));\n    }\n);",
            "title": "HalResponseFactory"
        },
        {
            "location": "/representations/#streams",
            "text": "A factory callable is necessary for generating streams as they are usually\nbacked by PHP resources, which are not immutable. Sharing instances could\nthus potentially lead to appending or overwriting contents!   By default, if you pass no arguments to the  HalResponseFactory  constructor, it\nassumes the following:   Usage of  Zend\\Diactoros\\Response .  A callable that returns a new  Zend\\Diactoros\\Stream  using  php://temp  as\n  its backing resource.  A  JsonRenderer  instance is created if none is provided.  An  XmlRenderer  instance is created if none is provided.   We provide a PSR-11 compatible factory for generating the  HalResponseFactory \nwhich uses zend-diactoros by default.",
            "title": "Streams"
        },
        {
            "location": "/representations/#using-the-factory",
            "text": "The factory exposes one method:  use Hal\\HalResource;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\npublic function createResponse(\n    ServerRequestInterface $request,\n    HalResource $resource,\n    string $mediaType = self::DEFAULT_CONTENT_TYPE\n) : ResponseInterface {  Generally speaking, you'll pass the current request instance, and the resource\nfor which you want to generate a response, and the factory will return a\nresponse based on its response prototype, with the following:   A  Content-Type  header with the base media type of  application/hal .  A message body containing the representation.   The request instance is used to determine what representation to create, based\non the  Accept  header. If it matches a JSON media type, a JSON representation\nis created, and the  Content-Type  will be appended with  +json ; for XML, an\nXML representation is created, and the  Content-Type  will be appended with +xml . If no media type is matched, XML is generated.  One practice often used is to provide a  custom media type  for your\nrepresentations. While they will still be HAL, this allows you to document the\nspecific structure of your resources, and potentially even validate them against\nJSON schema.  To do this, pass the media type when creating the response:  $response = $factory->createResponse(\n    $request,\n    $resource,\n    'application/vnd.book'\n);  Do not  pass the format (e.g.,  +json ,  +xml ) when doing so; the factory will\nappend the appropriate one based on content negotiation.",
            "title": "Using the factory"
        },
        {
            "location": "/representations/#forcing-collections-for-relations",
            "text": "HAL allows links and embedded resources to be represented as:   a single object  an array of objects of the same type   Internally, this package checks to see if only one of the item exists, and, if\nso, it will render it by itself. However, there are times you may want to force\nan array representation. As an example, if your resource models a car, and you\nhave a  wheels  relation, it would not make sense to return a single wheel, even\nif that's all the car currently has associated with it.  To accommodate this, we provide two features.  For links, you may pass a special attribute,  Hal\\Link::AS_COLLECTION , with a\nboolean value of  true ; when encountered, this will then be rendered as an\narray of links, even if only one link for that relation is present.  $link = new Link(\n    'wheels',\n    '/api/car/XXXX-YYYY-ZZZZ/wheels/111',\n    false,\n    [Link::AS_COLLECTION => true]\n);\n\n$resource = $resource->withLink($link);  In the above, you will then get the following within your representation:  \"_links\": {\n  \"wheels\": [\n    {\"href\": \"/api/car/XXXX-YYYY-ZZZZ/wheels/111\"}\n  ]\n}  To force an embedded resource to be rendered within an array, you have two\noptions.  First, and simplest, pass the resource within an array when calling withElement() ,  embed() , or passing data to the constructor:  // Constructor:\n$resource = new HalResource(['wheels' => [$wheel]]);\n\n// withElement():\n$resource = $resource->withElement('wheels', [$wheel]);\n\n// embed():\n$resource = $resource->embed('wheels', [$wheel]);  Alternately, you can call the  HalResource::embed  method with only the\nresource, passing the method a third argument, a flag indicating whether or not\nto force an array:  $resource = $resource->embed('wheels', $wheel, true);  In each of these cases, assuming no other wheels were provided to the final\nresource, you might get a representation such as the following:  \"_embedded\": {\n  \"wheels\": [\n    {\n      \"_links\" => {\"self\": {\"href\": \"...\"}}\n      \"id\": \"...\"\n    },\n  ]\n}",
            "title": "Forcing collections for relations"
        },
        {
            "location": "/factories/",
            "text": "Provided factories\n\n\nThis component provides a number of factories for use with\n\nPSR-11\n, in order to generate fully\nconfigured instances for your use.\n\n\nHal\\HalResponseFactoryFactory\n\n\n\n\nRegistered as service: \nHal\\HalResponseFactory\n\n\nGenerates instance of: \nHal\\HalResponseFactory\n\n\nDepends on:\n\n\nPsr\\Http\\Message\\ResponseInterface\n service. If not present, it will\n  check if zend-diactoros is installed, and use a new \nResponse\n instance\n  from that library; if not, it raises an exception.\n\n\nPsr\\Http\\Message\\StreamInterface\n service. This service must return a\n  a callable capable of returning a \nStreamInterface\n instance (in other\n  words, the service returns a \nfactory\n, and not the stream itself). If th\n  service is not present, the factory will check if zend-diactoros is\n  installed, and return a callable that returns a new \nStream\n instance from\n  that library; if not, it raises an exception.\n\n\nHal\\Renderer\\JsonRenderer\n service. If the service is not present, it\n  instantiates an instance itself.\n\n\nHal\\Renderer\\XmlRenderer\n service. If the service is not present, it\n  instantiates an instance itself.\n\n\n\n\n\n\n\n\nIf you want to use a different PSR-7 implementation for the response and stream,\nprovide services for \nPsr\\Http\\Message\\ResponseInterface\n and\n\nPsr\\Http\\Message\\StreamInterface\n, as described above.\n\n\nHal\\LinkGeneratorFactory\n\n\n\n\nRegistered as service: \nHal\\LinkGenerator\n\n\nGenerates instance of: \nHal\\LinkGenerator\n\n\nDepends on:\n\n\nHal\\LinkGenerator\\UrlGenerator\n service\n\n\n\n\n\n\n\n\nHal\\LinkGenerator\\ExpressiveUrlGeneratorFactory\n\n\n\n\nRegistered as service: \nHal\\LinkGenerator\\ExpressiveUrlGenerator\n\n\nGenerates instance of: \nHal\\LinkGenerator\\ExpressiveUrlGenerator\n\n\nDepends on:\n\n\nzendframework/zend-expressive-helpers\n package\n\n\nZend\\Expressive\\Helper\\UrlHelper\n service\n\n\nZend\\Expressive\\Helper\\ServerUrlHelper\n service (optional; if not provided,\n  URIs will be generated without authority information)\n\n\n\n\n\n\n\n\nHal\\LinkGenerator\\UrlGenerator\n\n\n\n\nRegistered as service: \nHal\\LinkGenerator\\UrlGenerator\n\n\nAliased to service: \nHal\\LinkGenerator\\ExpressiveUrlGenerator\n\n\n\n\nYou can either define an alternate alias, or map the \nUrlGenerator\n service\ndirectly to a factory that will return a valid instance.\n\n\nHal\\Metadata\\MetadataMapFactory\n\n\n\n\nRegistered as service: \nHal\\Metadata\\MetadataMap\n\n\nGenerates instance of: \nHal\\Metadata\\MetadataMap\n\n\nDepends on:\n\n\nconfig\n service; if not present, will use an empty array\n\n\n\n\n\n\n\n\nThis service uses the \nHal\\Metadata\\MetadataMap\n key of the \nconfig\n service in\norder to configure and return a \nHal\\Metadata\\MetadataMap\n instance. It expects\nthat value to be an array of elements, each with the following structure:\n\n\n[\n    '__class__' => 'Fully qualified class name of an AbstractMetadata type',\n    // additional key/value pairs as required by the metadata type.\n]\n\n\n\n\nThe additional pairs are as follows:\n\n\n\n\nFor \nUrlBasedResourceMetadata\n:\n\n\nresource_class\n: the resource class the metadata describes.\n\n\nurl\n: the URL to use when generating a self-relational link for the\n  resource.\n\n\nextractor\n: the extractor/hydrator service to use to extract resource\n  data.\n\n\n\n\n\n\nFor \nUrlBasedCollectionMetadata\n:\n\n\ncollection_class\n: the collection class the metadata describes.\n\n\ncollection_relation\n: the embedded relation for the collection in the\n  generated resource.\n\n\nurl\n: the URL to use when generating a self-relational link for the\n  collection resource.\n\n\npagination_param\n: the name of the parameter indicating what page of data\n  is present. Defaults to \"page\".\n\n\npagination_param_type\n: whether the pagination parameter is a query string\n  or path placeholder; use either \nAbstractCollectionMetadata::TYPE_QUERY\n\n  (\"query\") or \nAbstractCollectionMetadata::TYPE_PLACEHOLDER\n (\"placeholder\");\n  default is \"query\".\n\n\n\n\n\n\nFor \nRouteBasedResourceMetadata\n:\n\n\nresource_class\n: the resource class the metadata describes.\n\n\nroute\n: the route to use when generating a self relational link for the\n  resource.\n\n\nextractor\n: the extractor/hydrator service to use to extract resource\n  data.\n\n\nresource_identifier\n: what property in the resource represents its\n  identifier; defaults to \"id\".\n\n\nroute_identifier_placeholder\n: what placeholder in the route string\n  represents the resource identifier; defaults to \"id\".\n\n\nroute_params\n: an array of additional routing parameters to use when\n  generating the self relational link for the resource.\n\n\n\n\n\n\nFor \nRouteBasedCollectionMetadata\n:\n\n\ncollection_class\n: the collection class the metadata describes.\n\n\ncollection_relation\n: the embedded relation for the collection in the\n  generated resource.\n\n\nroute\n: the route to use when generating a self relational link for the\n  collection resource.\n\n\npagination_param\n: the name of the parameter indicating what page of data\n  is present. Defaults to \"page\".\n\n\npagination_param_type\n: whether the pagination parameter is a query string\n  or path placeholder; use either \nAbstractCollectionMetadata::TYPE_QUERY\n\n  (\"query\") or \nAbstractCollectionMetadata::TYPE_PLACEHOLDER\n (\"placeholder\");\n  default is \"query\".\n\n\nroute_params\n: an array of additional routing parameters to use when\n  generating the self relational link for the collection resource. Defaults\n  to an empty array.\n\n\nquery_string_arguments\n: an array of query string parameters to include\n  when generating the self relational link for the collection resource.\n  Defaults to an empty array.\n\n\n\n\n\n\n\n\nIf you have created custom metadata types, you can extend this class to\nsupport them. Create \ncreate<type>(array $metadata)\n methods for each\ntype you wish to support, where \n<type>\n is your custom class name, minus\nthe namespace.\n\n\nHal\\ResourceGeneratorFactory\n\n\n\n\nRegistered as service: \nHal\\ResourceGenerator\n\n\nGenerates instance of: \nHal\\ResourceGenerator\n\n\nDepends on:\n\n\nHal\\Metadata\\MetadataMap\n service\n\n\nZend\\Hydrator\\HydratorPluginManager\n service\n\n\nHal\\LinkGenerator\n service\n\n\n\n\n\n\n\n\nIf you wish to use a container implementation other than the\n\nZend\\Hydrator\\HydratorPluginManager\n, either register it under that service\nname, or create an alternate factory.",
            "title": "Factories"
        },
        {
            "location": "/factories/#provided-factories",
            "text": "This component provides a number of factories for use with PSR-11 , in order to generate fully\nconfigured instances for your use.",
            "title": "Provided factories"
        },
        {
            "location": "/factories/#halhalresponsefactoryfactory",
            "text": "Registered as service:  Hal\\HalResponseFactory  Generates instance of:  Hal\\HalResponseFactory  Depends on:  Psr\\Http\\Message\\ResponseInterface  service. If not present, it will\n  check if zend-diactoros is installed, and use a new  Response  instance\n  from that library; if not, it raises an exception.  Psr\\Http\\Message\\StreamInterface  service. This service must return a\n  a callable capable of returning a  StreamInterface  instance (in other\n  words, the service returns a  factory , and not the stream itself). If th\n  service is not present, the factory will check if zend-diactoros is\n  installed, and return a callable that returns a new  Stream  instance from\n  that library; if not, it raises an exception.  Hal\\Renderer\\JsonRenderer  service. If the service is not present, it\n  instantiates an instance itself.  Hal\\Renderer\\XmlRenderer  service. If the service is not present, it\n  instantiates an instance itself.     If you want to use a different PSR-7 implementation for the response and stream,\nprovide services for  Psr\\Http\\Message\\ResponseInterface  and Psr\\Http\\Message\\StreamInterface , as described above.",
            "title": "Hal\\HalResponseFactoryFactory"
        },
        {
            "location": "/factories/#hallinkgeneratorfactory",
            "text": "Registered as service:  Hal\\LinkGenerator  Generates instance of:  Hal\\LinkGenerator  Depends on:  Hal\\LinkGenerator\\UrlGenerator  service",
            "title": "Hal\\LinkGeneratorFactory"
        },
        {
            "location": "/factories/#hallinkgeneratorexpressiveurlgeneratorfactory",
            "text": "Registered as service:  Hal\\LinkGenerator\\ExpressiveUrlGenerator  Generates instance of:  Hal\\LinkGenerator\\ExpressiveUrlGenerator  Depends on:  zendframework/zend-expressive-helpers  package  Zend\\Expressive\\Helper\\UrlHelper  service  Zend\\Expressive\\Helper\\ServerUrlHelper  service (optional; if not provided,\n  URIs will be generated without authority information)",
            "title": "Hal\\LinkGenerator\\ExpressiveUrlGeneratorFactory"
        },
        {
            "location": "/factories/#hallinkgeneratorurlgenerator",
            "text": "Registered as service:  Hal\\LinkGenerator\\UrlGenerator  Aliased to service:  Hal\\LinkGenerator\\ExpressiveUrlGenerator   You can either define an alternate alias, or map the  UrlGenerator  service\ndirectly to a factory that will return a valid instance.",
            "title": "Hal\\LinkGenerator\\UrlGenerator"
        },
        {
            "location": "/factories/#halmetadatametadatamapfactory",
            "text": "Registered as service:  Hal\\Metadata\\MetadataMap  Generates instance of:  Hal\\Metadata\\MetadataMap  Depends on:  config  service; if not present, will use an empty array     This service uses the  Hal\\Metadata\\MetadataMap  key of the  config  service in\norder to configure and return a  Hal\\Metadata\\MetadataMap  instance. It expects\nthat value to be an array of elements, each with the following structure:  [\n    '__class__' => 'Fully qualified class name of an AbstractMetadata type',\n    // additional key/value pairs as required by the metadata type.\n]  The additional pairs are as follows:   For  UrlBasedResourceMetadata :  resource_class : the resource class the metadata describes.  url : the URL to use when generating a self-relational link for the\n  resource.  extractor : the extractor/hydrator service to use to extract resource\n  data.    For  UrlBasedCollectionMetadata :  collection_class : the collection class the metadata describes.  collection_relation : the embedded relation for the collection in the\n  generated resource.  url : the URL to use when generating a self-relational link for the\n  collection resource.  pagination_param : the name of the parameter indicating what page of data\n  is present. Defaults to \"page\".  pagination_param_type : whether the pagination parameter is a query string\n  or path placeholder; use either  AbstractCollectionMetadata::TYPE_QUERY \n  (\"query\") or  AbstractCollectionMetadata::TYPE_PLACEHOLDER  (\"placeholder\");\n  default is \"query\".    For  RouteBasedResourceMetadata :  resource_class : the resource class the metadata describes.  route : the route to use when generating a self relational link for the\n  resource.  extractor : the extractor/hydrator service to use to extract resource\n  data.  resource_identifier : what property in the resource represents its\n  identifier; defaults to \"id\".  route_identifier_placeholder : what placeholder in the route string\n  represents the resource identifier; defaults to \"id\".  route_params : an array of additional routing parameters to use when\n  generating the self relational link for the resource.    For  RouteBasedCollectionMetadata :  collection_class : the collection class the metadata describes.  collection_relation : the embedded relation for the collection in the\n  generated resource.  route : the route to use when generating a self relational link for the\n  collection resource.  pagination_param : the name of the parameter indicating what page of data\n  is present. Defaults to \"page\".  pagination_param_type : whether the pagination parameter is a query string\n  or path placeholder; use either  AbstractCollectionMetadata::TYPE_QUERY \n  (\"query\") or  AbstractCollectionMetadata::TYPE_PLACEHOLDER  (\"placeholder\");\n  default is \"query\".  route_params : an array of additional routing parameters to use when\n  generating the self relational link for the collection resource. Defaults\n  to an empty array.  query_string_arguments : an array of query string parameters to include\n  when generating the self relational link for the collection resource.\n  Defaults to an empty array.     If you have created custom metadata types, you can extend this class to\nsupport them. Create  create<type>(array $metadata)  methods for each\ntype you wish to support, where  <type>  is your custom class name, minus\nthe namespace.",
            "title": "Hal\\Metadata\\MetadataMapFactory"
        },
        {
            "location": "/factories/#halresourcegeneratorfactory",
            "text": "Registered as service:  Hal\\ResourceGenerator  Generates instance of:  Hal\\ResourceGenerator  Depends on:  Hal\\Metadata\\MetadataMap  service  Zend\\Hydrator\\HydratorPluginManager  service  Hal\\LinkGenerator  service     If you wish to use a container implementation other than the Zend\\Hydrator\\HydratorPluginManager , either register it under that service\nname, or create an alternate factory.",
            "title": "Hal\\ResourceGeneratorFactory"
        },
        {
            "location": "/cookbook/generating-custom-links-in-middleware/",
            "text": "Generating custom links in middleware\n\n\nIn most cases, you can rely on the \nResourceGenerator\n to generate self\nrelational links, and, in the case of paginated collections, pagination links.\n\n\nWhat if you want to generate other links to include in your resources, though?\n\n\nThe \nResourceGenerator\n provides access to the metadata map, hydrators, and link\ngenerator via getter methods:\n\n\n\n\ngetMetadataMap()\n\n\ngetHydrators()\n\n\ngetLinkGenerator()\n\n\n\n\nWe can thus use these in order to generate custom links as needed.\n\n\nCreating a custom link to include in a resource\n\n\nIn our first scenario, we'll create a \"search\" link for a resource.\n\n\nWe'll assume that you have composed a \nResourceGenerator\n instance in your\nmiddleware, and assigned it to the \n$resourceGenerator\n property.\n\n\nThe link we want to generate will look something like\n\n/api/books?query={searchParms}\n, and map to a route named \nbooks\n.\n\n\n$searchLink = $this->resourceGenerator\n    ->getLinkGenerator()\n    ->templatedFromRoute(\n        'search',\n        $request,\n        'books',\n        [],\n        ['query' => '{searchTerms}']\n    );\n\n\n\n\nYou could then compose it in your resource:\n\n\n$resource = $resource->withLink($searchLink);\n\n\n\n\nAdding metadata for generated links\n\n\nIn our second scenario, we'll consider a collection endpoint. It might include a\n\nper_page\n query string argument, to allow defining how many results to return\nper page, a \nsort\n argument, and a \nquery\n argument indicating the search\nstring. We know these at \nruntime\n, but not at the time we create our\nconfiguration, so we need to inject them \nafter\n we have our metadata created,\nbut \nbefore\n we generate our resource, so that the pagination links are\ncorrectly generated.\n\n\n$queryParams = $request->getQueryParams();\n$query       = $queryParams['query'] ?? '';\n$perPage     = $queryParams['per_page'] ?? 25;\n$sort        = $queryParams['sort'] ?? '';\n$metadataMap = $this->resourceGenerator->getMetadataMap();\n$metadata    = $metadataMap->get(BookCollection::class);\n\n$metadataQuery = $origMetadataQuery = $metadata->getQueryStringArguments();\n\nif ('' !== $query) {\n    $metadataQuery = array_merge($metadataQuery, ['query' => $query]);\n}\n\nif ('' !== $perPage) {\n    $metadataQuery = array_merge($metadataQuery, ['per_page' => $perPage]);\n}\n\nif ('' !== $sort) {\n    $metadataQuery = array_merge($metadataQuery, ['sort' => $sort]);\n}\n\n$metadata->setQueryStringArguments($metadataQuery);\n\n// ...\n\n$resource = $this->resourceGenerator->fromObject($books, $request);\n\n// Reset query string arguments\n$metadata->setQueryStringArguments($origMetadataQuery);\n\n\n\n\nThis will lead to links with URIs such as\n\n/api/books?query=Adams&per_page=5&sort=DESC&page=4\n.",
            "title": "Generating Custom Links In Middleware"
        },
        {
            "location": "/cookbook/generating-custom-links-in-middleware/#generating-custom-links-in-middleware",
            "text": "In most cases, you can rely on the  ResourceGenerator  to generate self\nrelational links, and, in the case of paginated collections, pagination links.  What if you want to generate other links to include in your resources, though?  The  ResourceGenerator  provides access to the metadata map, hydrators, and link\ngenerator via getter methods:   getMetadataMap()  getHydrators()  getLinkGenerator()   We can thus use these in order to generate custom links as needed.",
            "title": "Generating custom links in middleware"
        },
        {
            "location": "/cookbook/generating-custom-links-in-middleware/#creating-a-custom-link-to-include-in-a-resource",
            "text": "In our first scenario, we'll create a \"search\" link for a resource.  We'll assume that you have composed a  ResourceGenerator  instance in your\nmiddleware, and assigned it to the  $resourceGenerator  property.  The link we want to generate will look something like /api/books?query={searchParms} , and map to a route named  books .  $searchLink = $this->resourceGenerator\n    ->getLinkGenerator()\n    ->templatedFromRoute(\n        'search',\n        $request,\n        'books',\n        [],\n        ['query' => '{searchTerms}']\n    );  You could then compose it in your resource:  $resource = $resource->withLink($searchLink);",
            "title": "Creating a custom link to include in a resource"
        },
        {
            "location": "/cookbook/generating-custom-links-in-middleware/#adding-metadata-for-generated-links",
            "text": "In our second scenario, we'll consider a collection endpoint. It might include a per_page  query string argument, to allow defining how many results to return\nper page, a  sort  argument, and a  query  argument indicating the search\nstring. We know these at  runtime , but not at the time we create our\nconfiguration, so we need to inject them  after  we have our metadata created,\nbut  before  we generate our resource, so that the pagination links are\ncorrectly generated.  $queryParams = $request->getQueryParams();\n$query       = $queryParams['query'] ?? '';\n$perPage     = $queryParams['per_page'] ?? 25;\n$sort        = $queryParams['sort'] ?? '';\n$metadataMap = $this->resourceGenerator->getMetadataMap();\n$metadata    = $metadataMap->get(BookCollection::class);\n\n$metadataQuery = $origMetadataQuery = $metadata->getQueryStringArguments();\n\nif ('' !== $query) {\n    $metadataQuery = array_merge($metadataQuery, ['query' => $query]);\n}\n\nif ('' !== $perPage) {\n    $metadataQuery = array_merge($metadataQuery, ['per_page' => $perPage]);\n}\n\nif ('' !== $sort) {\n    $metadataQuery = array_merge($metadataQuery, ['sort' => $sort]);\n}\n\n$metadata->setQueryStringArguments($metadataQuery);\n\n// ...\n\n$resource = $this->resourceGenerator->fromObject($books, $request);\n\n// Reset query string arguments\n$metadata->setQueryStringArguments($origMetadataQuery);  This will lead to links with URIs such as /api/books?query=Adams&per_page=5&sort=DESC&page=4 .",
            "title": "Adding metadata for generated links"
        }
    ]
}